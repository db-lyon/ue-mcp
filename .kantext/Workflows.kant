‚õ©Ô∏è:
  SpaceBond@Workflow:
    meaning: A common UE development workflow ‚Äî a sequence of tool calls and concepts that achieve a goal. The AI should recognize these patterns and follow them.
    purpose: Workflows encode best practices. They turn individual tool calls into coherent operations.

  Meaning@precondition:
    meaning: What must be true before starting this workflow
    Category: /Workflow/Gate

  Meaning@steps:
    meaning: Ordered sequence of operations
    Category: /Workflow/Sequence

  Meaning@postcondition:
    meaning: What should be true when the workflow succeeds
    Category: /Workflow/Gate

UnderstandProject:
  meaning: First-contact workflow. Build a mental model of a UE project from scratch.
  precondition: Project path is known.
  steps:
    1_load: set_project with .uproject path
    2_status: get_status to confirm mode and capabilities
    3_structure: list_assets in Content/ to understand content organization
    4_config: read_config Engine and read_config Game for project settings
    5_modules: list_modules to understand C++ structure (if Source/ exists)
    6_tags: list_config_tags or list_gameplay_tags to understand the tagging taxonomy
    7_key_assets: read_blueprint or read_asset on central gameplay classes
  postcondition: AI has a working mental model of the project's structure, conventions, and key types.

UnderstandClass:
  meaning: Deeply understand a single class ‚Äî its role, capabilities, and relationships.
  precondition: Project loaded. Class name known.
  steps:
    1_reflect: reflect_class (live) or read_cpp_header (offline) to get properties, functions, parent chain
    2_hierarchy: Walk parent chain via repeated reflect_class to understand inherited behavior
    3_references: read_asset to see what this class depends on and what depends on it
    4_instances: search_assets to find Blueprints derived from or using this class
    5_config: search_config for any config entries that affect this class
  postcondition: AI understands the class's complete surface ‚Äî what it has, what it does, where it fits.
  ü™ù ReflectionTools: /ToolSurface/Reflection
      connection: primary_discovery

UnderstandBlueprint:
  meaning: Comprehensive Blueprint comprehension workflow.
  precondition: Project loaded. Asset path known.
  steps:
    1_overview: read_blueprint to get structure, parent, variables, functions, components
    2_parent: reflect_class on the parent to understand inherited properties and functions
    3_interfaces: For each interface, reflect_class to understand the contract
    4_variables: Examine variable types ‚Äî for custom structs, reflect_struct; for custom enums, reflect_enum
    5_graphs: read_blueprint_graph for key graphs (EventGraph, ConstructionScript) to understand behavior
    6_dependencies: read_asset for imports to understand what this Blueprint relies on
  postcondition: AI can explain the Blueprint's purpose, modify it safely, or create similar ones.

CreateBlueprint:
  meaning: Blueprint creation workflow. Creates, populates, and verifies a new Blueprint.
  precondition: Live mode. Know the desired parent class, variables, and initial setup.
  steps:
    1_verify_parent: reflect_class on the intended parent to understand inherited capabilities
    2_create: create_blueprint with path and parent class
    3_add_variables: add_blueprint_variable for each variable (name, type, defaults)
    4_add_components: If Actor-based, add SCS components via add_blueprint_node
    5_add_logic: add_blueprint_node + connect_blueprint_pins for event graph logic
    6_compile: compile_blueprint ‚Äî check for errors
    7_fix: If errors, read the error details, fix, recompile
    8_save: save_asset
  postcondition: New Blueprint exists, compiles cleanly, and is saved.
  ü™ù MutationTools: /ToolSurface/EditorMutation
      connection: requires

ModifyBlueprint:
  meaning: Safe Blueprint modification workflow. Read-before-write with compilation verification.
  precondition: Live mode. Blueprint exists.
  steps:
    1_read: read_blueprint to understand current state
    2_plan: Determine minimal changes needed
    3_modify: Apply changes (add_blueprint_variable, add_blueprint_node, set_property, etc.)
    4_compile: compile_blueprint
    5_verify: read_blueprint again to confirm changes took effect
    6_save: save_asset if satisfied
  constraint: Never skip the initial read. Never skip compilation. Always verify.

DataTableWorkflow:
  meaning: Working with DataTables ‚Äî reading, understanding, and modifying row data.
  precondition: Project loaded.
  steps:
    1_discover: list_assets with type filter to find DataTables
    2_read: read_datatable to get schema and rows
    3_understand_schema: reflect_struct on the RowStruct to understand all columns and their types
    4_modify: set_property to change cell values (live mode)
    5_save: save_asset
  postcondition: AI understands the DataTable's schema and content.

DebugAtRuntime:
  meaning: Use PIE to inspect runtime state and debug issues.
  precondition: Live mode. Blueprint or actor in question is known.
  steps:
    1_start_pie: play_in_editor start
    2_wait: Let the game reach the state being investigated
    3_inspect: get_runtime_value on relevant actors and properties
    4_compare: Compare runtime values against CDO defaults (from read_blueprint) to spot anomalies
    5_stop: play_in_editor stop when done
  postcondition: AI has runtime evidence to diagnose the issue.
  ü™ù PIETools: /ToolSurface/PIEIntrospection
      connection: requires

PerformanceAudit:
  meaning: Identify potential performance issues via asset analysis.
  precondition: Project loaded.
  steps:
    1_survey: list_assets recursively to understand content volume
    2_large_assets: Sort assets by complexity (export count) to find bloated Blueprints
    3_dep_chains: read_asset on critical assets to check for excessive hard references
    4_config: read_config Engine to check rendering, streaming, and GC settings
    5_tags: search_config for relevant performance settings (r., sg., gc.)
  postcondition: AI has identified potential hotspots and can recommend specific optimizations.

ConfigTuning:
  meaning: Find and modify engine/game configuration for a desired behavior change.
  precondition: Project loaded. Desired behavior known.
  steps:
    1_search: search_config for keywords related to the desired behavior
    2_read: read_config on the relevant config file to understand the section structure
    3_understand: Identify which CVar or setting controls the behavior
    4_modify: set_property or direct edit of the INI file (outside MCP scope) with the new value
  postcondition: AI knows exactly which config key to change and what values are valid.

UnderstandAnimSystem:
  meaning: Comprehend a character's animation setup end-to-end ‚Äî from AnimBlueprint state machines through montages to individual sequences.
  precondition: Live mode. Character Blueprint or AnimBlueprint path known.
  steps:
    1_find: list_anim_assets to survey all animation content in the relevant directory
    2_anim_bp: read_anim_blueprint to understand the state machine structure, skeleton, and driving variables
    3_reflect: reflect_class on the AnimInstance class to understand the variables that drive transitions
    4_montages: read_anim_montage on key montages to understand sections, notifies, and slot tracks
    5_sequences: read_anim_sequence on referenced sequences to understand lengths, rates, and curves
    6_blendspaces: read_blendspace on any blendspaces to understand locomotion blending
  postcondition: AI understands the full animation pipeline ‚Äî what drives state transitions, what each montage does, and how motion blends.
  ü™ù AnimTools: /ToolSurface/Animation
      connection: primary_discovery

CreateMontage:
  meaning: Set up an animation montage for a gameplay action (attack, ability, item use).
  precondition: Live mode. AnimSequence exists. Target skeleton known.
  steps:
    1_inspect_sequence: read_anim_sequence to understand length and existing notifies
    2_create: Create the montage asset (via editor or existing asset)
    3_add_notifies: add_anim_notify at key times ‚Äî e.g. damage window start/end, sound cue, VFX trigger
    4_verify: read_anim_montage to confirm sections and notifies are correct
    5_test: Wire the montage into the AnimBlueprint and test via PIE
  postcondition: Montage exists with correct timing, notifies fire at the right moments.
  constraint: Notify timing must match the animation frames. Always inspect the sequence length first.

BuildUI:
  meaning: Understand and work with a Widget Blueprint's UI structure.
  precondition: Live mode. Widget Blueprint path known.
  steps:
    1_survey: list_widget_blueprints to find all UI assets in the project
    2_tree: read_widget_tree to understand the full hierarchy ‚Äî panels, containers, leaf widgets
    3_details: get_widget_details on key widgets (buttons, text, progress bars) for type-specific properties
    4_animations: read_widget_animations to understand UMG animations and what they affect
    5_variables: Check the Widget Blueprint's variables to understand data bindings
  postcondition: AI understands the UI layout, widget types, bindings, and animations.
  ü™ù WidgetTools: /ToolSurface/WidgetUMG
      connection: primary_discovery

ModifyUI:
  meaning: Safely modify a Widget Blueprint ‚Äî change text, colors, visibility, properties.
  precondition: Live mode. Widget Blueprint exists. Widget name known.
  steps:
    1_read: read_widget_tree to understand current state
    2_inspect: get_widget_details on the target widget to see all current property values
    3_modify: set_widget_property to change the desired property
    4_verify: get_widget_details again to confirm the change took effect
    5_undo: If wrong, undo to revert
    6_save: save_asset if satisfied
  constraint: Always read before writing. Always verify after writing.

LevelComposition:
  meaning: Work with level layout ‚Äî place, arrange, and inspect actors in the world.
  precondition: Live mode. Level is open in editor.
  steps:
    1_survey: get_world_outliner to understand what's already placed
    2_filter: get_world_outliner with classFilter to find specific actor types
    3_inspect: get_actor_details on actors of interest for components and properties
    4_place: place_actor to add new actors with position, rotation, label, folder
    5_arrange: move_actor to adjust transforms
    6_cleanup: delete_actor to remove unwanted actors
    7_save: save_asset to persist level changes
  postcondition: Level is populated and organized.
  ü™ù LevelTools: /ToolSurface/LevelManipulation
      connection: primary_discovery

MaterialSetup:
  meaning: Understand and configure materials for an asset.
  precondition: Live mode. Material or material instance path known.
  steps:
    1_read: read_material to understand the base material ‚Äî shading model, blend mode, expressions
    2_params: list_material_parameters to see all tweakable parameters with current values
    3_instance: If needed, create_material_instance from the base material
    4_tune: set_material_parameter to adjust scalar (roughness, metallic), vector (color), or texture params
    5_verify: list_material_parameters again to confirm new values
    6_save: save_asset
  postcondition: Material instance exists with correct parameter values applied.
