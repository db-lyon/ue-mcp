‚õ©Ô∏è:
  SpaceBond@Workflow:
    meaning: A common UE development workflow ‚Äî a sequence of tool calls and concepts that achieve a goal. The AI should recognize these patterns and follow them.
    purpose: Workflows encode best practices. They turn individual tool calls into coherent operations.

  Meaning@precondition:
    meaning: What must be true before starting this workflow
    Category: /Workflow/Gate

  Meaning@steps:
    meaning: Ordered sequence of operations
    Category: /Workflow/Sequence

  Meaning@postcondition:
    meaning: What should be true when the workflow succeeds
    Category: /Workflow/Gate

UnderstandProject:
  meaning: First-contact workflow. Build a mental model of a UE project from scratch.
  precondition: Project path is known.
  steps:
    1_load: set_project with .uproject path
    2_status: get_status to confirm mode and capabilities
    3_structure: list_assets in Content/ to understand content organization
    4_config: read_config Engine and read_config Game for project settings
    5_modules: list_modules to understand C++ structure (if Source/ exists)
    6_tags: list_config_tags or list_gameplay_tags to understand the tagging taxonomy
    7_key_assets: read_blueprint or read_asset on central gameplay classes
  postcondition: AI has a working mental model of the project's structure, conventions, and key types.

UnderstandClass:
  meaning: Deeply understand a single class ‚Äî its role, capabilities, and relationships.
  precondition: Project loaded. Class name known.
  steps:
    1_reflect: reflect_class (live) or read_cpp_header (offline) to get properties, functions, parent chain
    2_hierarchy: Walk parent chain via repeated reflect_class to understand inherited behavior
    3_references: read_asset to see what this class depends on and what depends on it
    4_instances: search_assets to find Blueprints derived from or using this class
    5_config: search_config for any config entries that affect this class
  postcondition: AI understands the class's complete surface ‚Äî what it has, what it does, where it fits.
  ü™ù ReflectionTools: /ToolSurface/Reflection
      connection: primary_discovery

UnderstandBlueprint:
  meaning: Comprehensive Blueprint comprehension workflow.
  precondition: Project loaded. Asset path known.
  steps:
    1_overview: read_blueprint to get structure, parent, variables, functions, components
    2_parent: reflect_class on the parent to understand inherited properties and functions
    3_interfaces: For each interface, reflect_class to understand the contract
    4_variables: Examine variable types ‚Äî for custom structs, reflect_struct; for custom enums, reflect_enum
    5_graphs: read_blueprint_graph for key graphs (EventGraph, ConstructionScript) to understand behavior
    6_dependencies: read_asset for imports to understand what this Blueprint relies on
  postcondition: AI can explain the Blueprint's purpose, modify it safely, or create similar ones.

CreateBlueprint:
  meaning: Blueprint creation workflow. Creates, populates, and verifies a new Blueprint.
  precondition: Live mode. Know the desired parent class, variables, and initial setup.
  steps:
    1_verify_parent: reflect_class on the intended parent to understand inherited capabilities
    2_create: create_blueprint with path and parent class
    3_add_variables: add_blueprint_variable for each variable (name, type, defaults)
    4_add_components: If Actor-based, add SCS components via add_blueprint_node
    5_add_logic: add_blueprint_node + connect_blueprint_pins for event graph logic
    6_compile: compile_blueprint ‚Äî check for errors
    7_fix: If errors, read the error details, fix, recompile
    8_save: save_asset
  postcondition: New Blueprint exists, compiles cleanly, and is saved.
  ü™ù MutationTools: /ToolSurface/EditorMutation
      connection: requires

ModifyBlueprint:
  meaning: Safe Blueprint modification workflow. Read-before-write with compilation verification.
  precondition: Live mode. Blueprint exists.
  steps:
    1_read: read_blueprint to understand current state
    2_plan: Determine minimal changes needed
    3_modify: Apply changes (add_blueprint_variable, add_blueprint_node, set_property, etc.)
    4_compile: compile_blueprint
    5_verify: read_blueprint again to confirm changes took effect
    6_save: save_asset if satisfied
  constraint: Never skip the initial read. Never skip compilation. Always verify.

DataTableWorkflow:
  meaning: Working with DataTables ‚Äî reading, understanding, and modifying row data.
  precondition: Project loaded.
  steps:
    1_discover: list_assets with type filter to find DataTables
    2_read: read_datatable to get schema and rows
    3_understand_schema: reflect_struct on the RowStruct to understand all columns and their types
    4_modify: set_property to change cell values (live mode)
    5_save: save_asset
  postcondition: AI understands the DataTable's schema and content.

DebugAtRuntime:
  meaning: Use PIE to inspect runtime state and debug issues.
  precondition: Live mode. Blueprint or actor in question is known.
  steps:
    1_start_pie: play_in_editor start
    2_wait: Let the game reach the state being investigated
    3_inspect: get_runtime_value on relevant actors and properties
    4_compare: Compare runtime values against CDO defaults (from read_blueprint) to spot anomalies
    5_stop: play_in_editor stop when done
  postcondition: AI has runtime evidence to diagnose the issue.
  ü™ù PIETools: /ToolSurface/PIEIntrospection
      connection: requires

PerformanceAudit:
  meaning: Identify potential performance issues via asset analysis.
  precondition: Project loaded.
  steps:
    1_survey: list_assets recursively to understand content volume
    2_large_assets: Sort assets by complexity (export count) to find bloated Blueprints
    3_dep_chains: read_asset on critical assets to check for excessive hard references
    4_config: read_config Engine to check rendering, streaming, and GC settings
    5_tags: search_config for relevant performance settings (r., sg., gc.)
  postcondition: AI has identified potential hotspots and can recommend specific optimizations.

ConfigTuning:
  meaning: Find and modify engine/game configuration for a desired behavior change.
  precondition: Project loaded. Desired behavior known.
  steps:
    1_search: search_config for keywords related to the desired behavior
    2_read: read_config on the relevant config file to understand the section structure
    3_understand: Identify which CVar or setting controls the behavior
    4_modify: set_property or direct edit of the INI file (outside MCP scope) with the new value
  postcondition: AI knows exactly which config key to change and what values are valid.

UnderstandAnimSystem:
  meaning: Comprehend a character's animation setup end-to-end ‚Äî from AnimBlueprint state machines through montages to individual sequences.
  precondition: Live mode. Character Blueprint or AnimBlueprint path known.
  steps:
    1_find: list_anim_assets to survey all animation content in the relevant directory
    2_anim_bp: read_anim_blueprint to understand the state machine structure, skeleton, and driving variables
    3_reflect: reflect_class on the AnimInstance class to understand the variables that drive transitions
    4_montages: read_anim_montage on key montages to understand sections, notifies, and slot tracks
    5_sequences: read_anim_sequence on referenced sequences to understand lengths, rates, and curves
    6_blendspaces: read_blendspace on any blendspaces to understand locomotion blending
  postcondition: AI understands the full animation pipeline ‚Äî what drives state transitions, what each montage does, and how motion blends.
  ü™ù AnimTools: /ToolSurface/Animation
      connection: primary_discovery

CreateMontage:
  meaning: Set up an animation montage for a gameplay action (attack, ability, item use).
  precondition: Live mode. AnimSequence exists. Target skeleton known.
  steps:
    1_inspect_sequence: read_anim_sequence to understand length and existing notifies
    2_create: Create the montage asset (via editor or existing asset)
    3_add_notifies: add_anim_notify at key times ‚Äî e.g. damage window start/end, sound cue, VFX trigger
    4_verify: read_anim_montage to confirm sections and notifies are correct
    5_test: Wire the montage into the AnimBlueprint and test via PIE
  postcondition: Montage exists with correct timing, notifies fire at the right moments.
  constraint: Notify timing must match the animation frames. Always inspect the sequence length first.

BuildUI:
  meaning: Understand and work with a Widget Blueprint's UI structure.
  precondition: Live mode. Widget Blueprint path known.
  steps:
    1_survey: list_widget_blueprints to find all UI assets in the project
    2_tree: read_widget_tree to understand the full hierarchy ‚Äî panels, containers, leaf widgets
    3_details: get_widget_details on key widgets (buttons, text, progress bars) for type-specific properties
    4_animations: read_widget_animations to understand UMG animations and what they affect
    5_variables: Check the Widget Blueprint's variables to understand data bindings
  postcondition: AI understands the UI layout, widget types, bindings, and animations.
  ü™ù WidgetTools: /ToolSurface/WidgetUMG
      connection: primary_discovery

ModifyUI:
  meaning: Safely modify a Widget Blueprint ‚Äî change text, colors, visibility, properties.
  precondition: Live mode. Widget Blueprint exists. Widget name known.
  steps:
    1_read: read_widget_tree to understand current state
    2_inspect: get_widget_details on the target widget to see all current property values
    3_modify: set_widget_property to change the desired property
    4_verify: get_widget_details again to confirm the change took effect
    5_undo: If wrong, undo to revert
    6_save: save_asset if satisfied
  constraint: Always read before writing. Always verify after writing.

LevelComposition:
  meaning: Work with level layout ‚Äî place, arrange, and inspect actors in the world.
  precondition: Live mode. Level is open in editor.
  steps:
    1_survey: get_world_outliner to understand what's already placed
    2_filter: get_world_outliner with classFilter to find specific actor types
    3_inspect: get_actor_details on actors of interest for components and properties
    4_place: place_actor to add new actors with position, rotation, label, folder
    5_arrange: move_actor to adjust transforms
    6_cleanup: delete_actor to remove unwanted actors
    7_save: save_asset to persist level changes
  postcondition: Level is populated and organized.
  ü™ù LevelTools: /ToolSurface/LevelManipulation
      connection: primary_discovery

MaterialSetup:
  meaning: Understand and configure materials for an asset.
  precondition: Live mode. Material or material instance path known.
  steps:
    1_read: read_material to understand the base material ‚Äî shading model, blend mode, expressions
    2_params: list_material_parameters to see all tweakable parameters with current values
    3_instance: If needed, create_material_instance from the base material
    4_tune: set_material_parameter to adjust scalar (roughness, metallic), vector (color), or texture params
    5_verify: list_material_parameters again to confirm new values
    6_save: save_asset
  postcondition: Material instance exists with correct parameter values applied.

PCGScatterWorkflow:
  meaning: Build a procedural content pipeline from scratch using PCG ‚Äî from graph creation through node wiring to execution.
  precondition: Live mode. Know what to scatter (mesh) and where (surface/volume).
  steps:
    1_survey: list_pcg_graphs to see existing graphs for reference or reuse
    2_create: create_pcg_graph at the desired asset path
    3_sampler: add_pcg_node with type PCGSurfaceSampler to generate initial points from landscape
    4_filter: add_pcg_node with density or point filter to refine placement (slope, height, exclusion zones)
    5_transform: add_pcg_node with PCGTransformPoints for random rotation/scale variation
    6_spawner: add_pcg_node with PCGStaticMeshSpawner, set mesh reference in settings
    7_wire: connect_pcg_nodes to create the pipeline: Sampler ‚Üí Filter ‚Üí Transform ‚Üí Spawner
    8_tune: set_pcg_node_settings to adjust density, scale ranges, filter thresholds
    9_place: add_pcg_volume in the level with the graph and desired bounds
    10_execute: execute_pcg_graph to generate and preview results
    11_iterate: sample_landscape at key points to verify terrain context, adjust settings, re-execute
  postcondition: PCG volume generates content procedurally with correct density, filtering, and mesh placement.
  constraint: Always wire nodes before executing. Always verify landscape context with sample_landscape when filtering by terrain properties.
  ü™ù PCGTools: /ToolSurface/PCG
      connection: primary_discovery
  ü™ù LandscapeSampling: /ToolSurface/Landscape/sample_landscape
      connection: verification

TerrainSetup:
  meaning: Set up or modify the landscape for a level ‚Äî material, layers, sculpting, heightmap import.
  precondition: Live mode. Level with landscape is open.
  steps:
    1_info: get_landscape_info to understand current terrain setup (resolution, material, size)
    2_layers: list_landscape_layers to see existing paint layers
    3_material: set_landscape_material if a new landscape material is needed
    4_add_layers: add_landscape_layer_info for any new paint layers (dirt, rock, snow, etc.)
    5_heightmap: import_landscape_heightmap if working from authored terrain data
    6_sculpt: sculpt_landscape to shape terrain ‚Äî raise peaks, flatten plateaus, smooth transitions
    7_paint: paint_landscape_layer to apply material layers by region
    8_verify: sample_landscape at key coordinates to confirm height and layer weights
    9_splines: list_landscape_splines to check road/river paths
  postcondition: Landscape has correct shape, materials, and layer distribution.
  ü™ù LandscapeTools: /ToolSurface/Landscape
      connection: primary_discovery

FoliageDistribution:
  meaning: Configure and paint foliage across a landscape ‚Äî trees, grass, rocks with density and placement rules.
  precondition: Live mode. Landscape exists with paint layers. Foliage type assets available.
  steps:
    1_survey: list_foliage_types to see what's already placed
    2_settings: get_foliage_type_settings on each type to understand placement rules
    3_tune: set_foliage_type_settings to adjust density, scale range, ground slope, height range, landscape layer filter
    4_paint: paint_foliage at target locations with appropriate radius and density
    5_verify: sample_foliage in painted regions to confirm instance count and distribution
    6_refine: Adjust density or erase_foliage in over-populated areas
    7_landscape_check: sample_landscape to verify terrain context matches foliage expectations
  postcondition: Foliage is distributed naturally with correct density tied to landscape layers and terrain features.
  constraint: Foliage density couples to landscape layers. Always verify with sample_foliage after painting. Use erase_foliage + undo if results are wrong.
  ü™ù FoliageTools: /ToolSurface/Foliage
      connection: primary_discovery
  ü™ù LandscapeSampling: /ToolSurface/Landscape/sample_landscape
      connection: verification

WorldBuildingPipeline:
  meaning: End-to-end outdoor world-building workflow combining Landscape, Foliage, and PCG for a complete environment.
  precondition: Live mode. Empty or in-progress level.
  steps:
    1_terrain: Follow TerrainSetup workflow ‚Äî heightmap, material, layers, sculpting
    2_landscape_verify: sample_landscape across grid of points to build mental model of the terrain
    3_foliage: Follow FoliageDistribution workflow ‚Äî configure types, paint, verify density
    4_pcg_scatter: Follow PCGScatterWorkflow ‚Äî procedural rock/prop scattering based on landscape data
    5_actors: Use LevelComposition workflow to place unique actors, landmarks, gameplay elements
    6_materials: Use MaterialSetup workflow for terrain and prop materials
    7_full_verify: sample_landscape + sample_foliage + get_world_outliner to survey final state
    8_save: save_asset
  postcondition: Level has shaped terrain, painted layers, distributed foliage, procedural scattering, and placed actors.
  constraint: This is a large workflow. Break it into sub-workflows and verify at each stage.
